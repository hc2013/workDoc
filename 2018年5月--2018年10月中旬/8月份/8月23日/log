1.MoreLikeThisQuery的测试
	标准：分数

2.BM25

对于Query的研究，已经进入到必须细化的阶段了，不能放过任何一个分支，不放过任何一个点
		假定所有的点都是有重要意义的，务必要都搞清楚
=================================================================================
关于MLT的boost的使用
	是在CreateQuery中，根据是否开启boost选项，进行分支的
	如果默认不开boost，那么所有的Term形成一个裸的BooleanQuery，boost都是1
	如果开了boost，那么，以scoreTerm.score作为依据，进行boost计算，这里有两个有趣的地方
		1.bestScore的选用，从逻辑上看，是以PriortrityQueue的第一个，也就是以Score最高的作为bestScore
		2.就是“芹菜”，“苦瓜”的tf相同，为什么score略有差异？

		3.如果输入的是多篇文档，会是什么样的流程


=======================================================================================
关于Lucene Priority的研究
	top，是返回最小值，不删除（在1个时间单位内）
	pop，是删除并返回最小值

	updateTop，更新最小，也就是heap[1]做下滤，log时间返回
============================================================================================
经过比对，“芹菜”和“苦瓜”的tf值相同，但是idf值不同，恩，这没什么疑问的
============================================================================================	
在Search中的ExecutorService，是为了parallelize execution of the collection,也就是对collect操作的一个并行化
应该是与Query无关的
============================================================================================	
关于Search阶段的Query
	第一个重点，就是BooleanQuery的creatWeight方法
	

=================================================================================================

关于MLT的各个参数
	MaxNumTokensParsed：example doc中需要parse的token的最大值
			这里的example doc指的是没有TV的输入doc，对于这部分的设置，可以避免parse过多的Token从而浪费过多时间

	MaxQueryTerms：从expamle doc中摘取的term的个数，默认是25
	
	MaxDocFreqPct:最大的dpcFreq百分比，其实只是MaxDocFreq的百分树表述
		其仍然是作用与MaxDocFreq才能生效的
=================================================================================================================





